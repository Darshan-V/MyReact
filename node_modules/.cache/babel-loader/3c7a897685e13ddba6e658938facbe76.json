{"ast":null,"code":"import _asyncToGenerator from \"/home/darshan/geekskool/React-Getting-Started-Projects/MyOwnReact/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"/home/darshan/geekskool/React-Getting-Started-Projects/MyOwnReact/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction createElement(type, props) {\n  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    children[_key - 2] = arguments[_key];\n  }\n  return {\n    type: type,\n    props: _objectSpread(_objectSpread({}, props), {}, {\n      children: children.map(function (child) {\n        return typeof child === \"object\" ? child : createTextElement(child);\n      })\n    })\n  };\n}\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: []\n    }\n  };\n}\nfunction createDom(fiber) {\n  var dom = fiber.type === \"TEXT_ELEMENT\" ? document.createTextNode(\"\") : document.createElement(fiber.type);\n  updateDom(dom, {}, fiber.props);\n  return dom;\n}\nvar isEvent = function isEvent(key) {\n  return key.startsWith(\"on\");\n};\nvar isProperty = function isProperty(key) {\n  return key !== \"children\" && !isEvent(key);\n};\nvar isNew = function isNew(prev, next) {\n  return function (key) {\n    return prev[key] !== next[key];\n  };\n};\nvar isGone = function isGone(prev, next) {\n  return function (key) {\n    return !(key in next);\n  };\n};\nfunction updateDom(_x, _x2, _x3) {\n  return _updateDom.apply(this, arguments);\n}\nfunction _updateDom() {\n  _updateDom = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dom, prevProps, nextProps) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            //Remove old or changed event listeners\n            Object.keys(prevProps).filter(isEvent).filter(function (key) {\n              return !(key in nextProps) || isNew(prevProps, nextProps)(key);\n            }).forEach(function (name) {\n              var eventType = name.toLowerCase().substring(2);\n              dom.removeEventListener(eventType, prevProps[name]);\n            });\n\n            // Remove old properties\n            Object.keys(prevProps).filter(isProperty).filter(isGone(prevProps, nextProps)).forEach(function (name) {\n              dom[name] = \"\";\n            });\n\n            // Set new or changed properties\n            // console.log(nextProps)\n            Object.keys(nextProps).filter(isProperty).filter(isNew(prevProps, nextProps)).forEach(function (name) {\n              dom[name] = nextProps[name];\n            });\n\n            // Add event listeners\n            Object.keys(nextProps).filter(isEvent).filter(isNew(prevProps, nextProps)).forEach(function (name) {\n              var eventType = name.toLowerCase().substring(2);\n              dom.addEventListener(eventType, nextProps[name]);\n            });\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _updateDom.apply(this, arguments);\n}\nfunction commitRoot() {\n  deletions.forEach(commitWork);\n  commitWork(wipRoot.child);\n  currentRoot = wipRoot;\n  wipRoot = null;\n}\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return;\n  }\n  var domParentFiber = fiber.parent;\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent;\n  }\n  var domParent = domParentFiber.dom;\n  if (fiber.effectTag === \"PLACEMENT\" && fiber.dom != null) {\n    domParent.appendChild(fiber.dom);\n  } else if (fiber.effectTag === \"UPDATE\" && fiber.dom != null) {\n    updateDom(fiber.dom, fiber.alternate.props, fiber.props);\n  } else if (fiber.effectTag === \"DELETION\") {\n    commitDeletion(fiber, domParent);\n  }\n  commitWork(fiber.child);\n  commitWork(fiber.sibling);\n}\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom);\n  } else {\n    commitDeletion(fiber.child, domParent);\n  }\n}\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element]\n    },\n    alternate: currentRoot\n  };\n  deletions = [];\n  nextUnitOfWork = wipRoot;\n}\nvar nextUnitOfWork = null;\nvar currentRoot = null;\nvar wipRoot = null;\nvar deletions = null;\nfunction workLoop(deadline) {\n  var shouldYield = false;\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    shouldYield = deadline.timeRemaining() < 1;\n  }\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot();\n  }\n  requestIdleCallback(workLoop);\n}\nrequestIdleCallback(workLoop);\nfunction performUnitOfWork(fiber) {\n  var isFunctionComponent = fiber.type instanceof Function;\n  if (isFunctionComponent) {\n    updateFunctionComponent(fiber);\n  } else {\n    updateHostComponent(fiber);\n  }\n  if (fiber.child) {\n    return fiber.child;\n  }\n  var nextFiber = fiber;\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n    nextFiber = nextFiber.parent;\n  }\n}\nvar wipFiber = null;\nvar hookIndex = null;\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber;\n  hookIndex = 0;\n  wipFiber.hooks = [];\n  var children = [fiber.type(fiber.props)];\n  reconcileChildren(fiber, children);\n}\nfunction useState(initial) {\n  var oldHook = wipFiber.alternate && wipFiber.alternate.hooks && wipFiber.alternate.hooks[hookIndex];\n  var hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: []\n  };\n  var actions = oldHook ? oldHook.queue : [];\n  actions.forEach(function (action) {\n    hook.state = action(hook.state);\n  });\n  var setState = function setState(action) {\n    hook.queue.push(action);\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot\n    };\n    nextUnitOfWork = wipRoot;\n    deletions = [];\n  };\n  wipFiber.hooks.push(hook);\n  hookIndex++;\n  return [hook.state, setState];\n}\nfunction updateHostComponent(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber);\n  }\n  reconcileChildren(fiber, fiber.props.children);\n}\nfunction reconcileChildren(wipFiber, elements) {\n  var index = 0;\n  var oldFiber = wipFiber.alternate && wipFiber.alternate.child;\n  var prevSibling = null;\n  while (index < elements.length || oldFiber != null) {\n    var element = elements[index];\n    var newFiber = null;\n    var sameType = oldFiber && element && element.type === oldFiber.type;\n    if (sameType) {\n      newFiber = {\n        type: oldFiber.type,\n        props: element.props,\n        dom: oldFiber.dom,\n        parent: wipFiber,\n        alternate: oldFiber,\n        effectTag: \"UPDATE\"\n      };\n    }\n    if (element && !sameType) {\n      newFiber = {\n        type: element.type,\n        props: element.props,\n        dom: null,\n        parent: wipFiber,\n        alternate: null,\n        effectTag: \"PLACEMENT\"\n      };\n    }\n    if (oldFiber && !sameType) {\n      oldFiber.effectTag = \"DELETION\";\n      deletions.push(oldFiber);\n    }\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n    if (index === 0) {\n      wipFiber.child = newFiber;\n    } else if (element) {\n      prevSibling.sibling = newFiber;\n    }\n    prevSibling = newFiber;\n    index++;\n  }\n}\nexport var Maverick = {\n  createElement: createElement,\n  render: render,\n  useState: useState\n};\nexport default Maverick;","map":{"version":3,"names":["createElement","type","props","children","map","child","createTextElement","text","nodeValue","createDom","fiber","dom","document","createTextNode","updateDom","isEvent","key","startsWith","isProperty","isNew","prev","next","isGone","prevProps","nextProps","Object","keys","filter","forEach","name","eventType","toLowerCase","substring","removeEventListener","addEventListener","commitRoot","deletions","commitWork","wipRoot","currentRoot","domParentFiber","parent","domParent","effectTag","appendChild","alternate","commitDeletion","sibling","removeChild","render","element","container","nextUnitOfWork","workLoop","deadline","shouldYield","performUnitOfWork","timeRemaining","requestIdleCallback","isFunctionComponent","Function","updateFunctionComponent","updateHostComponent","nextFiber","wipFiber","hookIndex","hooks","reconcileChildren","useState","initial","oldHook","hook","state","queue","actions","action","setState","push","elements","index","oldFiber","prevSibling","length","newFiber","sameType","Maverick"],"sources":["/home/darshan/geekskool/React-Getting-Started-Projects/MyOwnReact/src/Maverick.js"],"sourcesContent":["function createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map((child) =>\n        typeof child === \"object\"\n          ? child\n          : createTextElement(child)\n      ),\n    },\n  }\n}\n\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  }\n}\n\nfunction createDom(fiber) {\n  const dom =\n    fiber.type === \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(fiber.type)\n  updateDom(dom, {}, fiber.props)\n\n  return dom\n}\n\nconst isEvent = (key) => key.startsWith(\"on\")\nconst isProperty = (key) =>\n  key !== \"children\" && !isEvent(key)\nconst isNew = (prev, next) => (key) =>\n  prev[key] !== next[key]\nconst isGone = (prev, next) => (key) =>\n  !(key in next)\n\nasync function updateDom(\n  dom,\n  prevProps,\n  nextProps\n) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter(\n      (key) =>\n        !(key in nextProps) ||\n        isNew(prevProps, nextProps)(key)\n    )\n    .forEach((name) => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.removeEventListener(\n        eventType,\n        prevProps[name]\n      )\n    })\n\n  // Remove old properties\n  Object.keys(prevProps)\n    .filter(isProperty)\n    .filter(isGone(prevProps, nextProps))\n    .forEach((name) => {\n      dom[name] = \"\"\n    })\n\n  // Set new or changed properties\n  // console.log(nextProps)\n  Object.keys(nextProps)\n    .filter(isProperty)\n    .filter(isNew(prevProps, nextProps))\n    .forEach((name) => {\n      dom[name] = nextProps[name]\n    })\n\n  // Add event listeners\n  Object.keys(nextProps)\n    .filter(isEvent)\n    .filter(isNew(prevProps, nextProps))\n    .forEach((name) => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.addEventListener(\n        eventType,\n        nextProps[name]\n      )\n    })\n}\n\nfunction commitRoot() {\n  deletions.forEach(commitWork)\n  commitWork(wipRoot.child)\n  currentRoot = wipRoot\n  wipRoot = null\n}\n\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n\n  let domParentFiber = fiber.parent\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent\n  }\n  const domParent = domParentFiber.dom\n\n  if (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (\n    fiber.effectTag === \"UPDATE\" &&\n    fiber.dom != null\n  ) {\n    updateDom(\n      fiber.dom,\n      fiber.alternate.props,\n      fiber.props\n    )\n  } else if (fiber.effectTag === \"DELETION\") {\n    commitDeletion(fiber, domParent)\n  }\n\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom)\n  } else {\n    commitDeletion(fiber.child, domParent)\n  }\n}\n\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    alternate: currentRoot,\n  }\n  deletions = []\n  nextUnitOfWork = wipRoot\n}\n\nlet nextUnitOfWork = null\nlet currentRoot = null\nlet wipRoot = null\nlet deletions = null\n\nfunction workLoop(deadline) {\n  let shouldYield = false\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.timeRemaining() < 1\n  }\n\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot()\n  }\n\n  requestIdleCallback(workLoop)\n}\n\nrequestIdleCallback(workLoop)\n\nfunction performUnitOfWork(fiber) {\n  const isFunctionComponent =\n    fiber.type instanceof Function\n  if (isFunctionComponent) {\n    updateFunctionComponent(fiber)\n  } else {\n    updateHostComponent(fiber)\n  }\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n\nlet wipFiber = null\nlet hookIndex = null\n\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber\n  hookIndex = 0\n  wipFiber.hooks = []\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex]\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: [],\n  }\n\n  const actions = oldHook ? oldHook.queue : []\n  actions.forEach((action) => {\n    hook.state = action(hook.state)\n  })\n\n  const setState = (action) => {\n    hook.queue.push(action)\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot,\n    }\n    nextUnitOfWork = wipRoot\n    deletions = []\n  }\n\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state, setState]\n}\n\nfunction updateHostComponent(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n  reconcileChildren(fiber, fiber.props.children)\n}\n\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let oldFiber =\n    wipFiber.alternate && wipFiber.alternate.child\n  let prevSibling = null\n\n  while (\n    index < elements.length ||\n    oldFiber != null\n  ) {\n    const element = elements[index]\n    let newFiber = null\n\n    const sameType =\n      oldFiber &&\n      element &&\n      element.type === oldFiber.type\n\n    if (sameType) {\n      newFiber = {\n        type: oldFiber.type,\n        props: element.props,\n        dom: oldFiber.dom,\n        parent: wipFiber,\n        alternate: oldFiber,\n        effectTag: \"UPDATE\",\n      }\n    }\n    if (element && !sameType) {\n      newFiber = {\n        type: element.type,\n        props: element.props,\n        dom: null,\n        parent: wipFiber,\n        alternate: null,\n        effectTag: \"PLACEMENT\",\n      }\n    }\n    if (oldFiber && !sameType) {\n      oldFiber.effectTag = \"DELETION\"\n      deletions.push(oldFiber)\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber\n    } else if (element) {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n}\n\nexport const Maverick = {\n  createElement,\n  render,\n  useState,\n}\nexport default Maverick\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}